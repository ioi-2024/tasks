# 樹 (Tree)

請考慮一棵包含 $N$ 個**節點**的**樹**，
編號從 $0$ 到 $N-1$。
編號 $0$ 的節點稱為**根節點**。
除了根節點，每個節點有一個單一的**父節點**。
對每個編號 $i$，$1 \leq i < N$，節點 $i$ 的父節點編號是 $P[i]$，且 $P[i] < i$。
我們也假設 $P[0] = -1$。

對於任一個編號 $i$ 的節點 ($0 \leq i < N$)，
節點 $i$ 的子樹是一個由以下節點所形成的集合：
 * 節點 $i$，以及
 * 任何以節點 $i$ 為父節點之節點，以及
 * 任何以節點 $i$ 為父節點的父節點之節點，以及
 * 任何以節點 $i$ 為父節點的父節點的父節點之節點，以及
 * 以此類推。

下圖以一棵有 $N = 6$ 個節點的樹為範例。
除了根節點沒有父節點，每條有箭頭的線將一個節點連接到它的父節點。 
節點 $2$ 的子樹包含節點 $2, 3, 4$ 及 $5$，節點 $0$ 的子樹包含樹中所有 $6$ 個節點，而節點 $4$ 的子樹只包含節點 $4$。

![](subtrees.png "150")

每個節點會被指定一個非負整數的**權重**。
我們將節點 $i$ ($0 \leq i < N$) 的權重以 $W[i]$ 表示。

你的任務是寫一個程式來回答 $Q$ 個問題，每個問題會以一組正整數 $(L, R)$ 指定。
請用以下方式計算出問題的答案。

請對樹中每個節點指定一個整數，稱為節點的**係數**。
將這些指定的係數以一個序列 $C[0], \ldots, C[N-1]$ 表示，其中 $C[i]$ ($0 \leq i < N$) 表示指定給節點 $i$ 的係數。我們將這個序列稱為一個**係數序列**。
請注意係數序列中的元素可能有負值、$0$、或正值。

對於一個問題 $(L, R)$，如果每個節點 $i$ ($0 \leq i < N$) 符合以下條件：其子樹中所有節點係數的加總不小於 $L$ 且不大於 $R$ ，則為一個**合法**係數序列。

對於一個給定的係數序列 $C[0], \ldots, C[N-1]$，一個節點 $i$ 的成本為 $|C[i]| \cdot W[i]$，其中 $|C[i]|$ 為 $C[i]$ 的絕對值。

最後，**總成本**為所有節點的成本總和。
你的任務是對每個問題計算合法係數序列中之**最小總成本**。

對於每一個問題，至少存在一組合法係數序列。

## 實作細節 (Implementation Details)

你必須實作以下兩個程序：

```
void init(std::vector&lt;int&gt; P, std::vector&lt;int&gt; W)
```

* $P$, $W$: 皆為長度為 $N$ 的整數陣列，分別表示每個節點的父節點編號及權重。
* 對每筆測資，這個程序會在評分程式與你的程式互動的一開始被呼叫一次。
```
long long query(int L, int R)
```
* $L$，$R$：代表一個問題的兩個整數值。
* 對每筆測資，在`init`被呼叫後，這個程序會被呼叫 $Q$ 次。
* 這個程序必須回傳所給定問題的答案。

## 限制條件 (Constraints)

* $1 \leq N \leq 200\,000$。
* $1 \leq Q \leq 100\,000$。
* $P[0] = -1$。
* 對於每個 $i$，若 $1 \leq i < N$，則 $0 \leq P[i] < i$。 
* 對於每個 $i$，若 $0 \leq i < N$，則 $0 \leq W[i] \leq 1\,000\,000$。
* 在每個問題中 $1 \leq L \leq R \leq 1\,000\,000$。

## 子任務 (Subtasks)

| 子任務 | 分數 | 額外限制 |
| :-----: | :----: | ---------------------- |
|   1     |  $10$  |對於每個 $i$，若 $1 \leq i < N$，則 $Q \leq 10$ 且 $W[P[i]] \leq W[i]$ 
|   2     |  $13$  | $Q \leq 10$；$N \leq 2\,000$
|   3     |  $18$  | $Q \leq 10$；$N \leq 60\,000$
|   4     |  $7$   |對於每個 $i$，若 $0 \leq i < N$，則 $W[i] = 1$。
|   5     |  $11$  |對於每個 $i$，若 $0 \leq i < N$，則 $W[i] \leq 1$。
|   6     |  $22$  | $L = 1$。
|   7     |  $19$  | 沒有額外限制。



## 範例 (Examples)

考慮下列呼叫：

```
init([-1, 0, 0], [1, 1, 1])
```
這棵樹有 $3$ 個節點，根節點以及它的 $2$ 個子節點。
所有的節點的權重皆為 $1$。

```
query(1, 1)
```

在這個問題中，$L = R = 1$，這意謂每棵子樹的係數總和必定等於 $1$。
考慮係數序列為 $[-1, 1, 1]$，這棵樹及對應的係數(在灰色方塊中) 顯示如下。

![](ex1.png "150")

對每個節點 $i$ ($0 \leq i < 3$)，在節點 $i$ 的子樹中所有節點的係數總和等於 $1$，因此是合法的。
其總成本的計算如下：

| 節點編號 | 權重 | 係數 | 成本                      |
| :----: | :----: | :---------: | :-----------------------: |
|   0    |   1    |     -1      | $\mid -1 \mid \cdot 1 = 1$
|   1    |   1    |      1      | $\mid 1 \mid \cdot 1 = 1$
|   2    |   1    |      1      | $\mid 1 \mid \cdot 1 = 1$

因此總成本為 $3$。
這是唯一的合法係數序列，因此呼叫結果應該回傳 $3$。

```
query(1, 2)
```
可由係數序列 $[0, 1, 1]$ 求得這個問題的最小總成本為 $2$。

## 範例評分程式 (Sample Grader)

輸入格式 (Input format):

```
N
P[1]  P[2] ...  P[N-1]
W[0]  W[1] ...  W[N-2] W[N-1]
Q
L[0]  R[0]
L[1]  R[1]
...
L[Q-1]  R[Q-1]
```
其中 $L[j]$ 及 $R[j]$ (對於 $0 \leq j < Q$) 表示第 $j$ 次呼叫 `query` 所輸入的參數。
請注意因為評分程式不會讀 $P[0]$ 的值，輸入的第二行**只有 $N-1$ 個整數**。

輸出格式 (Output format):
```
A[0]
A[1]
...
A[Q-1]
```
其中 $A[j]$ (對於 $0 \leq j < Q$) 為第 $j$ 次呼叫 `query` 所回傳的值。