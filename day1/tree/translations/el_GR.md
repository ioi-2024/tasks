# Δέντρο

Έστω ένα **δέντρο** που αποτελείται από $N$ **κορυφές**,
αριθμημένες από το $0$ έως το $N-1$.
Η κορυφή $0$ ονομάζεται **ρίζα**.
Κάθε κορυφή, εκτός από τη ρίζα, έχει έναν μόνο **γονέα**.
Για κάθε $i$, τέτοιο ώστε $1 \leq i < N$,
ο γονέας της κορυφής $i$ είναι η κορυφή $P[i]$, όπου $P[i] < i$.
Επίσης υποθέτουμε ότι $P[0] = -1$.

Για οποιαδήποτε κορυφή $i$ ($0 \leq i < N$),
το **υποδέντρο** της $i$ είναι το σύνολο των εξής κορυφών:
* $i$, και
* κάθε κορυφή της οποίας ο γονέας είναι η $i$, και
* κάθε κορυφή της οποίας ο γονέας του γονέα είναι η $i$, και
* κάθε κορυφή της οποίας ο γονέας του γονέα του γονέα είναι η $i$, και
* κ.ο.κ.

Η εικόνα παρακάτω δείχνει ένα παράδειγμα δέντρου που αποτελείται από $N = 6$ κορυφές.
Κάθε βέλος συνδέει μια κορυφή με τον γονέα της,
εκτός από τη ρίζα, η οποία δεν έχει γονέα.
Το υποδέντρο της κορυφής $2$ περιέχει τις κορυφές $2, 3, 4$ και $5$.
Το υποδέντρο της κορυφής $0$ περιέχει όλες τις $6$ κορυφές του δέντρου
και το υποδέντρο της κορυφής $4$ περιέχει μόνο την κορυφή $4$.

![](subtrees.png "150")

Σε κάθε κορυφή αποδίδεται ένα μη αρνητικό ακέραιο **βάρος**.
Συμβολίζουμε το βάρος της κορυφής $i$ ($0 \leq i < N$) ως $W[i]$.

Η αποστολή σας είναι να γράψετε ένα πρόγραμμα που θα απαντά σε $Q$ ερωτήματα,
το καθένα από τα οποία ορίζεται από ένα ζεύγος θετικών ακεραίων  $(L, R)$.
Η απάντηση στο ερώτημα πρέπει να υπολογίζεται ως εξής.

Σκεφτείτε την ανάθεση ενός ακεραίου,
που ονομάζεται **συντελεστής**, σε κάθε κορυφή του δέντρου.
Μια τέτοια ανάθεση περιγράφεται από μια ακολουθία $C[0], \ldots, C[N-1]$,
όπου $C[i]$ ($0 \leq i < N$) είναι ο συντελεστής που αποδίδεται στην κορυφή $i$.
Ας ονομάσουμε αυτή την ακολουθία **ακολουθία συντελεστών**.
Σημειώστε ότι τα στοιχεία της ακολουθίας συντελεστών μπορούν να είναι αρνητικά, $0$ ή θετικά.

Για ένα ερώτημα $(L, R)$,
μια ακολουθία συντελεστών ονομάζεται **έγκυρη**
εάν, για κάθε κορυφή $i$ ($0 \leq i < N$),
ισχύει η εξής συνθήκη:
το άθροισμα των συντελεστών των κορυφών στο υποδέντρο της κορυφής $i$
δεν είναι μικρότερο από $L$ και δεν είναι μεγαλύτερο από $R$.

Για μια δεδομένη ακολουθία συντελεστών $C[0], \ldots, C[N-1]$,
το **κόστος** μιας κορυφής $i$ είναι $|C[i]| \cdot W[i]$,
όπου $|C[i]|$ δηλώνει την απόλυτη τιμή του $C[i]$.
Τέλος, το **συνολικό κόστος** είναι το άθροισμα των κόστους όλων των κορυφών.
Η αποστολή σας είναι να υπολογίσετε, για κάθε ερώτημα,
το **ελάχιστο συνολικό κόστος** που μπορεί να επιτευχθεί από μια έγκυρη ακολουθία συντελεστών.

Μπορεί να δειχτεί ότι για κάθε ερώτημα, υπάρχει πάντα τουλάχιστον μια έγκυρη ακολουθία συντελεστών.

## Λεπτομέρειες Υλοποίησης

Θα πρέπει να υλοποιήσετε τις εξής δύο διαδικασίες:

```
void init(std::vector&lt;int&gt; P, std::vector&lt;int&gt; W)
```

* $P$, $W$: πίνακες ακεραίων μήκους $N$
   που καθορίζουν τους γονείς και τα βάρη.
* Αυτή η διαδικασία καλείται ακριβώς μία φορά
   στην αρχή της αλληλεπίδρασης μεταξύ του βαθμολογητή και του προγράμματός σας σε κάθε περίπτωση δοκιμής(testcase).

```
long long query(int L, int R)
```
* $L$, $R$: ακέραιοι που περιγράφουν ένα ερώτημα.
* Αυτή η διαδικασία καλείται $Q$ φορές μετά την κλήση της `init` σε κάθε περίπτωση δοκιμής.
* Αυτή η διαδικασία πρέπει να επιστρέψει την απάντηση στο δεδομένο ερώτημα.

## Περιορισμοί

* $1 \leq N \leq 200\,000$
* $1 \leq Q \leq 100\,000$
* $P[0] = -1$
* $0 \leq P[i] < i$ για κάθε $i$ τέτοιο ώστε $1 \leq i < N$
* $0 \leq W[i] \leq 1\,000\,000$ για κάθε $i$ τέτοιο ώστε $0 \leq i < N$
* $1 \leq L \leq R \leq 1\,000\,000$ σε κάθε ερώτημα

## Subtasks

| Subtask | Βαθμοί | Πρόσθετοι Περιορισμοί |
| :----------: | :----: | --------------------- |
|      1       |  $10$  | $Q \leq 10$; $W[P[i]] \leq W[i]$ για κάθε $i$ τέτοιο ώστε $1 \leq i < N$
|      2       |  $13$  | $Q \leq 10$; $N \leq 2\,000$
|      3       |  $18$  | $Q \leq 10$; $N \leq 60\,000$
|      4       |   $7$  | $W[i] = 1$ για κάθε $i$ τέτοιο ώστε $0 \leq i < N$
|      5       |  $11$  | $W[i] \leq 1$ για κάθε $i$ τέτοιο ώστε $0 \leq i < N$
|      6       |  $22$  | $L = 1$
|      7       |  $19$  | Χωρίς πρόσθετους περιορισμούς.

## Παραδείγματα

Σκεφτείτε τις εξής κλήσεις:

```
init([-1, 0, 0], [1, 1, 1])
```
Το δέντρο αποτελείται από $3$ κορυφές, τη ρίζα και τα $2$ παιδιά της.
Όλες οι κορυφές έχουν βάρος $1$.

```
query(1, 1)
```

Σε αυτό το ερώτημα $L = R = 1$,
που σημαίνει ότι το άθροισμα των συντελεστών σε κάθε υποδέντρο πρέπει να είναι ίσο με $1$.
Σκεφτείτε την ακολουθία συντελεστών $[-1, 1, 1]$.
Το δέντρο και οι αντίστοιχοι συντελεστές (σε σκιασμένα ορθογώνια) απεικονίζονται παρακάτω.

![](ex1.png "150")

Για κάθε κορυφή $i$ ($0 \leq i < 3$), το άθροισμα των συντελεστών όλων των κορυφών
στο υποδέντρο της $i$ είναι ίσο με $1$.
Επομένως, αυτή η ακολουθία συντελεστών είναι έγκυρη.
Το συνολικό κόστος υπολογίζεται ως εξής:

| Κορυφή | Βάρος | Συντελεστής | Κόστος                       |
| :----: | :---: | :---------: | :--------------------------: |
|   0    |   1   |     -1      | $\mid -1 \mid \cdot 1 = 1$
|   1    |   1   |      1      | $\mid 1 \mid \cdot 1 = 1$
|   2    |   1   |      1      | $\mid 1 \mid \cdot 1 = 1$

Επομένως, το συνολικό κόστος είναι $3$.
Αυτή είναι η μόνη έγκυρη ακολουθία συντελεστών,
επομένως αυτή η κλήση πρέπει να επιστρέψει $3$.

```
query(1, 2)
```
Το ελάχιστο συνολικό κόστος για αυτό το ερώτημα είναι $2$,
και επιτυγχάνεται όταν η ακολουθία συντελεστών είναι $[0, 1, 1]$.

## Υπόδειγμα Grader

Μορφή εισόδου:

```
N
P[1]  P[2] ...  P[N-1]
W[0]  W[1] ...  W[N-2] W[N-1]
Q
L[0]  R[0]
L[1]  R[1]
...
L[Q-1]  R[Q-1]
```

όπου τα $L[j]$ και $R[j]$
(για $0 \leq j < Q$)
είναι τα ορίσματα εισόδου στην $j$-στη κλήση της `query`.
Σημειώστε ότι η δεύτερη γραμμή της εισόδου περιέχει **μόνο $N-1$ ακέραιους**,
καθώς αυτός ο grader δεν διαβάζει την τιμή του $P[0]$.

Μορφή εξόδου:
```
A[0]
A[1]
...
A[Q-1]
```

όπου το $A[j]$
(για $0 \leq j < Q$)
είναι η τιμή που επιστρέφεται από την $j$-στη κλήση της `query`.
