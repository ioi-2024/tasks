# لغز أبي الهول

لدى أبو الهول العظيم لغز يجب عليك حله.
سيتم إعطاؤك بياناً مكوناً من $N$ عقدة، ترقم العقد من $0$ إلى $N-1$.
يوجد هناك $M$ وصلة في البيان، مرقمة من $0$ إلى $M-1$.
كل وصلة تصل زوجاً من العقد المختلفة، وهي ذات اتجاهين.
بشكل أدق من أجل كل $j$ من $0$ إلى $M - 1$ (متضمنة الطرفين)، الوصلة $j$ تصل العقدتين $X[j]$ و $Y[j]$.
لن يكون هناك أكثر من وصلة واحدة تصل بين أي زوج من العقد.
نقول عن عقدتين أنهما **متجاورتان** إذا كانتا موصولتين بوصلة.

نقول عن سلسلة من العقد $v_0, v_1, \ldots, v_k$ (من أجل $k \ge 0$) أنها **طريق** إذا كانت كل عقدتين متتاليتين $v_l$ و $v_{l+1}$
 (من أجل كل $l$ حيث أن $0 \le l \lt k$) متجاورتين.
 نقول عن الطريق $v_0, v_1, \ldots, v_k$ أنه **يربط** العقدتين $v_0$ و $v_k$.
 في البيان المعطى، أي زوج من العقد سيكون متصلاً بطريق ما.

هناك $N + 1$ لوناُ، مرقمة من $0$ إلى $N$.
اللون رقم $N$ هو لون خاص ويسمى **لون أبي الهول**.
سيتم تعيين لون لكل عقدة.
بشكل أدق، العقدة $i$ ($0 \le i \lt N$) يكون لونها $C[i]$.
يمكن لأكثر من عقدة أن يكون لها نفس اللون، ومن الممكن أيضاً أن يكون أحد الألوان غير مستخدم لتلوين أي عقدة.
ولا يوجد أي عقدة ملونة بلون أبي الهول، أي أن، $0 \le C[i] \lt N$ ($0 \le i \lt N$).

نقول عن الطريق $v_0, v_1, \ldots, v_k$ (من أجل $k \ge 0$) أنه **وحيد اللون** إذا كانت كل العقد على هذا الطريق لها نفس اللون، أي أن  $C[v_l] = C[v_{l+1}]$ (من أجل كل $l$ حيث أن $0 \le l \lt k$).
إضافة إلى ذلك، نقول عن العقدتين $p$ و $q$ ($0 \le p \lt N$, $0 \le q \lt N$) أنهما تقعان في نفس **المكون وحيد اللون** إذا كانتا متصلتين بطريق وحيد اللون.

انت تعرف ما هي العقد والوصلات، ولكنك لا تعرف ألوان العقد، وتريد معرفة ألوان العقد، عن طريق اجراء بعض **تجارب إعادة التلوين**.

في تجربة إعادة التلوين، يمكنك إعادة تلوين أي عدد من العقد.
بشكل أدق، لكي تقوم بتجربة إعادة التلوين، ستقوم بالبداية باختيار مصفوفة $E$ بطول $N$، حيث أنه من أجل كل $i$ ($0 \le i \lt N$)، $E[i]$ هي بين $-1$ و $N$ **متضمنة الطرفين**.
بعد ذلك، يكون لون كل عقدة $i$ هو $S[i]$ حيث أن قيمة $S[i]$ تحدد كما يلي:
* $C[i]$ أي اللون الأصلي لـ $i$ إذا كانت $E[i] = -1$، أو
* $E[i]$، غير ذلك

لاحظ أنه، ذلك يعني أنك يمكنك استخدام لون أبي الهول في عملية إعادة التلوين.

أخيراً، يعلن أبو الهول العظيم عدد المكونات أحادية اللون في البيان، بعد تعيين ألوان العقد الجديدة لكل $i$ إلى  $S[i]$ ($0 \le i \lt N$).
يتم تطبيق الألوان الجديدة فقط خلال هذه التجربة بالذات، وهكذا **يتم إعادة ألوان العقد إلى اللون الأصلي بعد انتهاء التجربة**.

مهمتك هي تحديد ألوان العقد في البيان عن طريق إجراء $2\,750$ تجربة إعادة تلوين على الأكثر.
يمكنك أيضاً الحصول على علامة جزئية إذا تمكنت من التحديد من أجل كل زوج من العقد المتجاورة فيما إذا كانت لها نفس اللون أم لا، بشكل صحيح. 


## تفاصيل البرمجة

يجب عليك برمجة الدالة التالي.

```
std::vector&lt;int&gt; find_colours(int N,
    std::vector&lt;int&gt; X, std::vector&lt;int&gt; Y)
```


* $N$:عدد العقد في البيان.
* $X$, $Y$: مصفوفتان بطول $M$ تصفان الوصلات.
* يجب على الدالة أن يعيد مصفوفة $G$ بطول $N$، تمثل ألوان العقد في البيان.
* يتم استدعاء الدالة مرة واحدة بالضبط من أجل كل حالة اختبار.

يمكن للتابع في الأعلى أن يقوم باستدعاء الدالة التالي للقيام بتجارب إعادة التلوين.


```
int perform_experiment(std::vector&lt;int&gt; E)
```


* $E$: مصفوفة بطول $N$ تحدد كيفية إعادة تلوين العقد.
* تعيد هذه الدالة عدد المكونات وحيدة اللون في البيان بعد عملية إعادة تلوين العقد وفقاً للمصفوفة $E$.
* يمكن استدعاء هذا الدالة $2\,750$ مرة على الأكثر.

نظام التصحيح **غير متكيف** ذلك يعني أن الوان العقد ثابتة ومحددة قبل استدعاء الدالة `find_colours`.

## القيود

* $2 \le N \le 250$
* $N - 1 \le M \le \frac{N \cdot (N - 1)}{2}$
* $0 \le X[j] \lt Y[j] \lt N$ من أجل كل $j$ حيث أن $0 \le j \lt M$.
* $X[j] \neq X[k]$ أو $Y[j] \neq Y[k]$
   من أجل كل $j$ و $k$ حيث أن $0 \le j \lt k \lt M$.
* كل زوج من العقد يجب أن يكون متصلاً بطريق ما.
* $0 \le C[i] \lt N$ من أجل كل $i$ حيث أن $0 \le i \lt N$.

## المسائل الجزئية

| المسألة الجزئية | العلامة  | القيود الإضافية |
| :-----: | :----: | ---------------------- |
| 1       | $3$    | $N = 2$
| 2       | $7$    | $N \le 50$
| 3       | $33$   | البيان هو طريق واحد: $M = N - 1$ والعقدتان $j$ و $j+1$ متجاورتان ($0 \leq j < M$).
| 4       | $21$   | البيان كامل: $M = \frac{N \cdot (N - 1)}{2}$ وأي عقدتين تكونان متجاورتين.
| 5       | $36$   | لا يوجد قيود إضافية.

في كل مسألة جزئية، يمكنك الحصول على علامة جزئية، إذا قام برنامجك من أجل كل زوج من العقد المتجاورة بتحديد فيما إذا كان لهما نفس اللون أم لا، بشكل صحيح. 

بشكل أدق، ستحصل على العلامة الكاملة للمسألة الجزئية إذا تمكنت في كل حالات الاختبار من أن تكون المصفوفة $G$ التي أعادها الدالة `find_colours` مطابقة تماماً للمصفوفة $C$ (أي $G[i] = C[i]$
 من أجل كل $i$ حيث أن $0 \le i \lt N$).

وإلا ستحصل على $50\%$ من علامة المسألة الجزئية إذا تحقق الشرطان التاليان لكل حالات الاختبار في هذه المسألة الجزئية:
* $0 \le G[i] \lt N$
   من أجل كل $i$ حيث أن $0 \le i \lt N$;
* من أجل كل $j$ حيث أن $0 \le j \lt M$:
  * $G[X[j]] = G[Y[j]]$ إذا وفقط إذا $C[X[j]] = C[Y[j]]$.

## مثال

ليكن لدينا الاستدعاء التالي.

```
find_colours(4, [0, 1, 0, 0], [1, 2, 2, 3])
```


من أجل هذا المثال، افترض أن الالوان (المخفية) للعقد معطاة بالمصفوفة $C = [2, 0, 0, 0]$.
هذا السيناريو معروض بالشكل التالي.
حيث تم تمثيل الألوان بشكل إضافي عن طريق ألوان على لصاقات بيضاء مرتبطة مع كل عقدة.

![example.png](sphinx_example.png "230")

يمكن للتابع أن يقوم باستدعاء `perform_experiment` كالآتي.

```
perform_experiment([-1, -1, -1, -1])
```


في هذا الاستدعاء، لن يتم تلوين أي عقدة وستحافظ كل العقد على ألوانها الاصلية.

لننظر إلى العقدة $1$ والعقدة $2$.
كلاهما لونهم $0$ والطريق $1, 2$ هو طريق أحادي اللون.
كنتيجة لذلك، العقدتين $1$ و $2$ موجودتان في نفس المكون أحادي اللون.

انظر إلى العقدتين $1$ والعقدة $3$.
على الرغم من أن كليهما له نفس اللون وهو $0$، إلا أنهما تقعان في مكونين أحاديي اللون مختلفين، لأنه لا يوجد بينهما طريق أحادي اللون.

بشكل كلي، هناك $3$ مكونات أحادية اللون، وهي العقد $\{0\}$, $\{1, 2\}$, و $\{3\}$.

يجب على هذا الاستدعاء أن يعيد $3$.

الآن، يمكن للتابع أن يقوم باستدعاء الدالة `perform_experiment` كالتالي.

```
perform_experiment([0, -1, -1, -1])
```


في هذا الاستدعاء، تم إعادة تلوين العقدة $0$ فقط، ليصبح لونها $0$، والذي يؤدي إلى التلوين المعروض بالشكل التالي.

![example.png](sphinx_order1.png "230")

هذا الاستدعاء يعيد $1$ لأن كل العقد تنتمي إلى نفس المكون أحادي اللون.
يمكننا الآن استنتاج أن العقد $1$, $2$, و $3$ لونها $0$.

يمكن للتابع أن يقوم باستدعاء الدالة `perform_experiment` كالتالي.

```
perform_experiment([-1, -1, -1, 2])
```


في هذا الاستدعاء تم إعادة تلوين العقدة $3$ ليصبح لونها $2$، والذي يؤدي إلى التلوين المعروض بالشكل التالي.

![example.png](sphinx_order2.png "230")

هذا الاستدعاء يعيد $2$ لأنه يوجد مكونان أحاديا اللون، تحتوي العقد $\{0, 3\}$ و $\{1, 2\}$ على التوالي.
ويمكننا استنتاج أن العقدة $0$ لونها $2$.

بعد ذلك، الدالة `find_colours` سيعيد المصفوفة $[2, 0, 0, 0]$.
لأن $C = [2, 0, 0, 0]$، وسيتم إعطاء العلامة الكاملة.

لاحظ أنه يوجد عدة قيم يمكن إعادتها للحصول على $50\%$ من العلامة، مثال $[1, 2, 2, 2]$ أو $[1, 2, 2, 3]$.

## Sample Grader

Input format:

```
N  M
C[0]  C[1] ... C[N-1]
X[0]  Y[0]
X[1]  Y[1]
...
X[M-1]  Y[M-1]
```


Output format:

```
L  Q
G[0]  G[1] ... G[L-1]
```


Here, $L$ is the length of the array $G$ returned by `find_colours`,
 and $Q$ is the number of calls to `perform_experiment`.



